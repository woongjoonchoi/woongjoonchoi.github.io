---
title : "Efficient GEMM"

excerpt: "Tiling"

categories:
  - GPU_Programming
tags:
  - [Software Engineering , GPU Programming]
# classes : wide
toc: true
toc_sticky: true
---

## Introduction
Matrix Multiplication은 다양한 과학 분야에서 널리 사용된다. Matrix Multiplication은 본질적으로 단순한 산술 연산의 집합으로 구성되어 있기 때문에, 상대적으로 더 많은 수의 코어(core)를 갖춘 GPU를 이용하여 효율적으로 수행된다. 그러나 GPU를 활용하여 Matrix Multiplication을 수행할 때, 빈번하게 발생하는 Memory Hierarchy 간 데이터 이동 문제가 성능 저하의 주요 원인이 된다.

일반적으로 Matrix Multiplication은 다음과 같이 정의된다.

$$
c_{ij} = \sum_{k} a_{ik} \times b_{kj}
$$

한 변의 길이가 $$O(N)$$인 행렬의 계산(computation) 복잡도는 $$O(N^3)$$이며, 계산을 수행하기 위해 GPU의 core에 로드되어야 하는 데이터의 크기는 $$O(N^2)$$이다. 데이터를 최소한으로 로드하면서 효율성을 극대화하기 위해서는 데이터가 한 번 로드될 때마다 $$O(N)$$의 연산(computation)을 수행해야 한다. 그러나 실제로 $$O(N^2)$$ 크기의 데이터는 일반적으로 매우 크기 때문에 모든 데이터를 한 번에 캐시(cache)에 로드하는 것이 불가능하다. 따라서 연산량은 동일하지만, 데이터를 여러 번 반복적으로 로드해야 하므로, 이러한 데이터의 빈번한 로드 과정이 병목 현상(bottleneck)의 주요 원인이 된다.

모든 $$N$$에 대해 앞서 정의한 일반적인 형태인 $$c_{ij} = \sum_{k} a_{ik} \times b_{kj}$$의 계산 방식을 그대로 수행한다면, 빈번한 데이터 로드 문제는 해결할 수 없다. 이 문제를 해결하기 위해, Matrix Multiplication의 정의를 수학적으로 동일하지만 다르게 해석하여 계산한다. 즉, Matrix Multiplication을 Block Matrix Multiplication의 형태로 재정의하여 계산하는 것이다. Block Matrix Multiplication을 활용하여 Matrix Multiplication을 수행하면 데이터 로드 횟수를 줄일 수 있다.

더 나아가, 각 Block 내에서도 Block Matrix Multiplication을 다시 수행하도록 분해하여 구현할 수 있다. 추가적으로, Block Multiplication 내에서도 Outer Product 형태로 정의하여 구현함으로써, 메모리 접근 효율성을 더욱 향상할 수 있다.

## BackGround

### Memory Hierarchy

### Compute Intensity


### Matrix Mutliplication Definition

#### Block Matrix Multiplication

#### Outer Product


Block Multiplication

Outer Product



## Tiling


### Block Tiling


### Warp Tiling


### Thread Tiling

## Conclusion